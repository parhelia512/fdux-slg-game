void main(
	float2 uv: TEXCOORD0,
	float3 ray: TEXCOORD1,	
	
	out float4 oColour	: COLOR,
	
	uniform sampler2D normaldepthTex: register(s0),
	uniform sampler2D randTex: register(s1),
	uniform	float4x4 viewMatrix,
	uniform float viewportH,
	uniform float viewportW,
	uniform float fov,
	uniform float farChip
	)
{

    const float3 RAND_SAMPLES[14] =
    {
        float3(1, 0, 0),
        float3(	-1, 0, 0),
        float3(0, 1, 0),
        float3(0, -1, 0),
        float3(0, 0, 1),
        float3(0, 0, -1),
        normalize(float3(1, 1, 1)),
        normalize(float3(-1, 1, 1)),
        normalize(float3(1, -1, 1)),
        normalize(float3(1, 1, -1)),
        normalize(float3(-1, -1, 1)),
        normalize(float3(-1, 1, -1)),
        normalize(float3(1, -1, -1)),
        normalize(float3(-1, -1, -1))
    };
	
	float4 nd = tex2D(normaldepthTex, uv);
	float3 viewpos = ray * farChip * nd.w;
	float3 worldnormal = nd.xyz * 2.0 -1.0;
	float3 viewnormal = normalize( mul((float3x3)viewMatrix, worldnormal));
	
	float aspect = viewportH / viewportW;
	float tfov = tan(fov / 2.0);
	
	float ao = 0;
	float3 Ref = normalize((tex2D(randTex,uv).xyz * 2.0) - 1.0 ); 
	for (int i=0;i<14;i++)  
	{
		float3 randray = 0.5 * (reflect( RAND_SAMPLES[i], Ref));
		float raydot=dot(normalize(randray),viewnormal);  
		if (raydot<0)  
			randray = -randray; 
		float3 samplepos = viewpos + randray;
		float2 projpos = float2(samplepos.x * aspect,  samplepos.y ) / (samplepos.z * tfov);
		float2 sampleuv = 0.5 * (1.0 + float2(-projpos.x, projpos.y));
		float sampledepth = tex2D(normaldepthTex, sampleuv).w * farChip;  
		float depthdiff= sampledepth + samplepos.z;  
		if (depthdiff> 0.1 && depthdiff < 2.0)
			ao += (2.0 - depthdiff) * 0.53;
	}	
	float final = 0.7 +  ao  / 28;
	
	oColour = float4(final, final, final, 1.0);
}